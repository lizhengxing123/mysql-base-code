# 索引使用

# 1、最左前缀法则
-- 联合索引最左边的字段必须在查询条件中，否则不会使用索引
-- 如果跳过了中间字段，后面的字段也不会使用索引

# 2、范围查询
-- 在联合索引中，范围查询(>,<)后面的字段不会使用索引
-- 规避方式，将 > 或 < 改为 >= 或 <=

# 3、索引列运算
-- 在索引列上进行运算，会导致索引失效

# 4、字符串不加引号
-- 字符串不加引号，会导致索引失效

# 5、模糊查询
-- 头部模糊匹配，会导致索引失效，
-- 尾部模糊匹配，不会导致索引失效

# 6、or连接的条件
-- 如果or前面的条件中包含索引列，or后面的条件中不包含索引列，那么涉及到的索引都不会被用到

# 7、数据分布影响
-- 如果mysql估计使用索引比全表扫描更慢，则不使用索引

# 8、sql提示
-- 是优化数据库的重要手段，在sql语句中加入一些人为的提示，来达到优化的目的
-- 8.1 use index
-- 强制使用索引
-- explain select * from tb_user use index(idx_name);

-- 8.2 ignore index
-- 忽略索引
-- explain select * from tb_user ignore index(idx_name);

-- 8.3 force index
-- 强制使用索引
-- explain select * from tb_user force index(idx_name);

# 9、覆盖索引
-- 指的是查询的字段全部都在索引中，不需要回表查询，效率较高
-- using index condition：需要回表查询
-- using where; using index：不需要回表查询

# 10、前缀索引
-- 指的是索引列的前n个字符，而不是整个列
-- 对于一些长文本来说很有用，前缀索引可以减少索引的大小，节约索引空间，提高索引效率
-- 但是前缀索引有一定的损失，因为前缀索引不能直接用于排序和分组，只能用于查询
-- 计算前缀索引的可选择性,可选择性越高，索引的效率就越高,1最好
-- select count(distinct substr(email, 1, 10))/count(*) from tb_user;
